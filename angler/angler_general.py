from skimage.feature import peak_local_max
from math import *
import numpy as np
import matplotlib.pyplot as plt
from skimage import io as skio
from skimage.draw import ellipse
from skimage.measure import label, regionprops
from skimage.transform import rotate
from skimage.morphology import convex_hull_image
from skimage.exposure import rescale_intensity
from reportlab.platypus import SimpleDocTemplate, Image, Paragraph, PageBreak, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import cm, inch
import ntpath
import tempfile
import time
import sys
from PyPDF2 import PdfFileMerger, PdfFileReader
from angler import *
from reportlab.platypus import SimpleDocTemplate, Image, Paragraph, PageBreak
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import cm,inch

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle,Patch
from io import BytesIO

import angler
import bioformats
from angler import *

from PyPDF2 import PdfFileMerger, PdfFileReader
import glob
import os
import time, sys
import tempfile
import gc
import pickle

import logging
import numpy as np
import pandas as pd

def FISH_finder_dry(folder_path,file_ext,FISH_ch,FISH_ch_names,thresh=0.5,exclude_border=40):
    '''
    This function performs a dry run to detect FISH spots.
    The sole purpose of this function to emprically find best threshold for a ceratin FISH experiment.

    Input Parameters:
    folder_path: str, A folder containing FISH mciroscopy data
    files_ext: str, file extension to search in the folder (e.g. "D3D.dv", ".dv",".flex")
    FISH_ch: tuple of ints containing channel numbers containing FISH signals (index is zero based)
    FISH_ch_names: tuple of strs containing channel names for FISH signals (e.g. "RP11-33o9", "lib11",etc)
    thresh: float 0.0-1.0 relative threshold of the peaks value, compared to maximum value of the image.
    exclude_border: int excludes local peaks that are in the border of an image.
    min_dist: int excludes local peaks that are closer than this value to each other. 
    '''
    from reportlab.lib.pagesizes import letter
    from reportlab.pdfgen import canvas

    


def FISH_finder(img,thresh,crop_size,exclude_border=2):
    '''
    This function finds the coordinates of local maxima in max-projected FISH
    data.

    It uses peak_local_max from skimage.feature module.  If two local maxima
    happen to be on proximity of 20 pixel,only the brighter one will be kept.

    Parameters:
    img: 2-D ndarray (i.e,single channel) 

    min_distance= minimum distance of two FISH spot
    
    thresh: flaot 0.0-1.0 relative threshold of the peaks value, compared to maximum value of the image.
    
    exclude_border: int excludes local peaks that are in the border of an image.


    Returns:
    ndarray: (row, column, â€¦) coordinates of peaks.

    '''

    min_loci_dist=int(sqrt(2*((crop_size/2)**2)))
    coordinates = peak_local_max(img, min_distance=min_loci_dist,threshold_rel=thresh,exclude_border=exclude_border)
    return coordinates
    

def im_prj(img,z_ind,method='max'):
    # img should be hyperstack image in numpy format.
    # You can findout which axis is z by the following coomand: img.shape
    # You can tell which axis is Z if you know number of Z stacks.
    
    #Project image along Z axis
    if method=="max":
        return(np.amax(img,axis=z_ind))
    if method=="sum":
        return(np.sum(img,axis=z_ind))

def rep_first_page(pars,title):


    sample_style_sheet = getSampleStyleSheet()
    flowables = []

    paragraph_1 = Paragraph(title, sample_style_sheet['Heading1'])
    flowables.append(paragraph_1)


    paragraph_2 = Paragraph(
        """This report has been generated by ANGLER package with the following parameters.""",
        sample_style_sheet['BodyText'])
    flowables.append(paragraph_2)

    para = Paragraph("This report was generated on %s" % time.strftime("%a, %d %b %Y %H:%M:%S"),
                     sample_style_sheet['BodyText'])
    flowables.append(para)

    para = Paragraph("Parameteres:", sample_style_sheet['Heading2'])
    flowables.append(para)

    # para = Paragraph("Microscopy file folder: %s" % pars["folder_path"], sample_style_sheet['BodyText'])
    # flowables.append(para)

    # para = Paragraph("Number of file in filer: %s" % pars["file_no"], sample_style_sheet['BodyText'])
    # flowables.append(para)

    # para = Paragraph("Report name: %s" % pars["pdf_report_path"], sample_style_sheet['BodyText'])
    # flowables.append(para)

    # for ch,threshold in zip(pars["FISH_ch"],pars['FISH_finder_threshold']):
    #     para = Paragraph("Threshold used for FISH_finder in channel {0}: {1}".format(ch,threshold), sample_style_sheet['BodyText'])
    #     flowables.append(para)

    # para = Paragraph("Exclude border: %i" % pars["exclude_border"], sample_style_sheet['BodyText'])
    # flowables.append(para)

    # para = Paragraph("Threshold used for feret in all channels %f" %pars['feret_threshold'], sample_style_sheet['BodyText'])
    # flowables.append(para)

    # para = Paragraph("Noise removed %s" %str(pars['noise_removal']), sample_style_sheet['BodyText'])
    # flowables.append(para)

    for key in pars.keys():
        para = Paragraph(key+": "+str(pars[str(key)]), sample_style_sheet['BodyText'])
        flowables.append(para)

    flowables.append(Spacer(1, 12))

    logo_path=os.path.join(os.path.dirname(__file__), "logo/angler_postcard.jpg")
    logo = Image(logo_path, width=2*inch, height=3*inch)
    logo.hAlign = 'CENTER'
    flowables.append(logo)
        

    flowables.append(PageBreak())

    return flowables


def path_leaf(path):

    head, tail = ntpath.split(path)
    return tail or ntpath.basename(head)


def update_progress(job_title, index, total):
    progress = index / total
    length = 20  # modify this to change the length
    block = int(round(length * progress))
    msg = "\r{0}: [{1}] {2}% : {3} out of {4}".format(job_title, "#" * block + "-" * (length - block),
                                                      round(progress * 100, 2), index, total)
    if progress >= 1: msg += " DONE\r\n"
    sys.stdout.write(msg)
    sys.stdout.flush()


def PDF_gen(flowables, path, counter):
    pdf_path = path + "/" + str(counter) + ".pdf"
    pdf_report = SimpleDocTemplate(pdf_path)
    sample_style_sheet = getSampleStyleSheet()
    pdf_report.build(flowables)


def pdf_merger(output_path, input_paths):
    merged = PdfFileMerger()

    for path in input_paths:
        merged.append(path)

    with open(output_path, 'wb') as fileobj:
        merged.write(fileobj)

def subtract_bkg(MicImage_cls):
    """
    Subtract background as measured by pixels mode from the image.
    Returns a new MicImage with previous meta data but new pixels.
    """
    from statistics import mode as dmode
    def modes_max(a):
        vals, cnts = np.unique(a, return_counts=True)
        max_cnts=cnts[cnts.argmax()]
        mode_ind=np.equal(cnts,np.full_like(cnts,max_cnts))
        modes=vals[mode_ind]
        return np.amax(modes)
    try:
        img_mod=np.full_like(MicImage_cls.pixels, dmode(MicImage_cls.pixels.flatten()))
    except:
        img_mod=np.full_like(MicImage_cls.pixels, modes_max(MicImage_cls.pixels))
    image_de_noise=MicImage()
    image_de_noise._metaData={**MicImage_cls._metaData}
    image_de_noise.pixels=np.subtract(MicImage_cls.pixels,img_mod)
    image_de_noise.prj("sum")
    image_de_noise.prj("max")
    return image_de_noise 

def feret(prj,pixel_size,threshold=0.5):
    from skimage import measure
    from scipy.spatial.distance import cdist
    
    def measure_feret(binary_image,pixel_size=1):
        feret={}
        contour= measure.find_contours(binary_image,0)[0]
        feret.update({"contour":contour})

        dist=np.triu(cdist(contour,contour,"euclidean"),0)
        max_dist=np.amax(dist)

        feret.update({"feret":max_dist*float(pixel_size)})
        max_dist_index=(np.where(dist==max_dist))
        max_dist_index=[max_dist_index[0],max_dist_index[1]]
        crd=list(zip(max_dist_index[0],max_dist_index[1]))[0]
        line=[[contour[crd[0],1],contour[crd[1],1]],[contour[crd[0],0],contour[crd[1],0]]]
        feret.update({"line":line})
        return feret
    
    feret={}
    feret.update({"feret_threshold":threshold})
    feret.update({"convex_hull":False})
    feret.update({"noise":False})
    feret.update({"box_color":"g"})
    feret.update(pixel_size)
    T=np.amax(prj)*threshold
    binary_prj=np.zeros_like(prj)
    binary_prj[prj>T]=1
    label_img, tot_objects = label(binary_prj,return_num=True)
    if tot_objects==1:        
        regions = regionprops(label_img, coordinates='xy') #Only workds with skimage=0.14.*. Starting 0.16 they are changing coordinate system.
        if regions[0].area<4:
            feret.update({"noise":True})
            feret.update({"box_color":"r"})

        feret.update({"convex_hull":False})

    elif tot_objects>1:
        chull=convex_hull_image(binary_prj)
        binary_prj[chull]=1
        label_img, tot_objects = label(binary_prj,return_num=True)
        feret.update({"convex_hull":True})
        feret.update({"box_color":"m"})
        regions = regionprops(label_img, coordinates='xy') #Only workds with skimage=0.14.*. Starting 0.16 they are changing coordinate system.
        if regions[0].area<4:
            feret.update({"noise":True})
            feret.update({"box_color":"r"})
    feret.update({"area":regions[0].area*(pixel_size["pixel_size"]**2)})
    measurement=measure_feret(binary_prj,pixel_size["pixel_size"])
    feret.update(measurement)


        

    return feret


def pixel_size(img):
    pixel={}
    if img.meta("pixel_size") is None:
        if img.meta("x_resolution") is None:
            pixel.update({"pixel_size":1,"pixel_type":"default=1px"})
        else:
            pixel.update({"pixel_size":img.meta("x_resolution"),"pixel_type":"x_resolution"})
    else:
        pixel.update({"pixel_size":img.meta("pixel_size"),"pixel_type":"xy_resolution"})
    return pixel

def FISH_finder_plotter(img,FISH_crds,crds_box_color):
    """
    annotates FISH image with coordinates found by FISH_finder.
    Parameters:
    img: MicImage 4D(3D +channels) instant
    FISH_crds: list of coordinates of FISH signal found by FISH_finder
    
    Returns: Marked figure.
    """

    rectangle_crds=crds-pars['crop_size']/2
    text_crds=[(x,y) for y,x in crds]

    # Make the graph
    fig, ax = plt.subplots(figsize=(7, 5),dpi=300, sharex=True, sharey=True)
    #             ax = axes.ravel()
    rgb=np.zeros((img.meta("size_y"),img.meta("size_x"),3),dtype=int)
    rgb[:,:,0]=rescale_intensity(img.maxprj[..., ch],out_range=(0, 255))
    rgb[:,:,1]=np.zeros((img.meta("size_y"),img.meta("size_x")),dtype=int)
    rgb[:,:,2]=rescale_intensity(img.maxprj[..., pars['DAPI_ch']],out_range=(0, 150))

    ax.imshow(rgb)
    loci_rectangles=[Rectangle((crd_x, crd_y),pars['crop_size'],pars['crop_size'],
        linewidth=0.5,edgecolor=crds_box_color[j],facecolor='none') for j,(crd_y, crd_x) in enumerate(rectangle_crds)]

    for j,rectangle in enumerate(loci_rectangles):
        ax.add_patch(rectangle)
        ax.annotate(str(j), c=crds_box_color[j],fontsize=7, xy=text_crds[j],
                xycoords='data', xytext=(10,10),
                textcoords='offset pixels')



    title = "Channel #:" + pars['ch_names'][ch]
    fig.suptitle(title, fontsize=10)
    return fig

def compaction_fish(pars):
    flowb_c = 0
    global temp_report_dir
    temp_report_dir = tempfile.TemporaryDirectory(dir="./")
    flowb_c = angler.PDF_gen(angler.rep_first_page(pars,title="ANGLER: compaction FISH analysis"), temp_report_dir.name, counter=flowb_c)

    sample_style_sheet = getSampleStyleSheet()
    if pars["#ofImages"] is "all":
        files = glob.glob(pars['folder_path'] + "/*" + pars['file_ext'])[:]
    else:
        files = glob.glob(pars['folder_path'] + "/*" + pars['file_ext'])[:pars['#ofImages']]
    # files = glob.glob(pars['folder_path'] + "/*" + pars['file_ext'])[:150]   
    tot = len(files)
    # report_cols=['file_name','ch#','crop#','feret-diameter','convex_hull']
    measurements=pd.DataFrame()
    print("start")
    for j, file_path in enumerate(files):
        flowbs = []
        #         Open Image
        img = angler.MicImage(image_path=file_path)
        para = Paragraph(path_leaf(file_path), sample_style_sheet['Heading2'])
        flowbs.append(para)

        for i, ch in enumerate(pars["FISH_ch"]):
            ch_measurements=pd.DataFrame()
            # crds = angler.FISH_finder(img.maxprj[..., ch], thresh=pars['FISH_finder_threshold'][ch],crop_size=pars['crop_size']) # For 2D crds
            crds=angler.FISH_finder(img.pixels[..., ch], thresh=pars['FISH_finder_threshold'][ch],
            crop_size=pars['crop_size']) #For 3D crds
            crds=[[i,[j,k]] for i,j,k in crds]
            for crd_no,(z_crd,xy_crd) in enumerate(crds):
                try:
                    measurement={}
                    measurement={"file_name":path_leaf(file_path)}
                    measurement.update({"channel":ch})
                    measurement.update({"crop#":crd_no})
                    measurement.update({"crop_coordinates":xy_crd})
                    # crop each crd
                    # crp=img.crop(center_coord=crd,channel=ch,crop_size=pars['crop_size']) # For 2D
                    
                    if pars['use_z']:
                        crp=crp=img.crop(center_coord=xy_crd,channel=ch,crop_size=pars['crop_size'],z_coord=z_crd,z_size=pars['number_of_stacks'])
                    else:
                        crp=crp=img.crop(center_coord=xy_crd,channel=ch,crop_size=pars['crop_size'],z_coord=None)

                    if pars["noise_removal"]:
                        # remove Background
                        no_noise=angler.subtract_bkg(crp)
                        # measure feret
                        feret_m=angler.feret(prj=no_noise.getPRJ(pars["prj_method"]),pixel_size=angler.pixel_size(no_noise),threshold=pars['feret_threshold'])
                    else:
                        # measure feret
                        feret_m=angler.feret(prj=crp.getPRJ(pars["prj_method"]),pixel_size=angler.pixel_size(crp),threshold=pars['feret_threshold'])
                    
                    #color code for plot
                    measurement.update(feret_m)
                    ch_measurements=ch_measurements.append(pd.DataFrame([measurement]),ignore_index=True)
                except:
                    print('Something went wrong with feret measurement of image',str(measurement['file_name']),str(measurement['crop#']))
            
            # Make the graph
            measurements=measurements.append(ch_measurements,ignore_index=True)
            # try:
            fig=angler.compaction_plotter(img,ch,ch_measurements,pars)
            buf = BytesIO()
            fig.savefig(buf, dpi=300, format="tiff")
            buf.seek(0)
            plt.close(fig)
            fig_img = Image(buf, 6.3 * inch, 4.5 * inch)
            flowbs.append(fig_img)
            # except:
                # print('Something went wrong with crd plotting of image',str(measurement['file_name']),str(measurement['crop#']))

        # flowb_c = angler.PDF_gen(flowables=flowbs, path=temp_report_dir.name, counter=flowb_c)
        angler.PDF_gen(flowables=flowbs, path=temp_report_dir.name, counter=path_leaf(file_path))
#         buf.close()
        bioformats.clear_image_reader_cache()
        angler.update_progress("Compaction_FISH:", index=j + 1, total=tot)
    pdf_paths = glob.glob(temp_report_dir.name + '/*.pdf')
    pdf_paths.sort()
    angler.pdf_merger(pars["pdf_report_path"], pdf_paths)
    temp_report_dir.cleanup()
    print("\n PDF report created in:{}".format(pars["pdf_report_path"]))


    cols=["file_name","channel","crop#","feret","feret_threshold","area","pixel_size","pixel_type","noise","convex_hull","box_color"]
    return measurements[cols]

def compaction_plotter(img,ch,ch_pandas,pars,prj_method="max"):
    """
    annotates FISH image with coordinates found by FISH_finder.
    Parameters:
    img: MicImage 4D(3D +channels) instant
    FISH_crds: list of coordinates of FISH signal found by FISH_finder
    
    Returns: Marked figure.
    """
    # crds=ch_pandas["crop_coordinates"]
    half_crop=int(pars['crop_size']/2)
    # rectangle_crds= crds-half_crop
    # text_crds=[(x,y) for y,x in crds]

    fig, ax = plt.subplots(figsize=(7, 5),dpi=300, sharex=True, sharey=True)
    rgb=np.zeros((img.meta("size_y"),img.meta("size_x"),3),dtype=int)
    rgb[:,:,0]=rescale_intensity(img.getPRJ(pars['plotting_method'])[..., ch],out_range=(0, 255))
    rgb[:,:,1]=np.zeros((img.meta("size_y"),img.meta("size_x")),dtype=int)
#     rgb[:,:,2]=np.zeros((img.meta("size_y"),img.meta("size_x")),dtype=int)
    rgb[:,:,2]=rescale_intensity(img.getPRJ(pars['plotting_method'])[..., pars['DAPI_ch']],out_range=(0, 200))

    ax.imshow(rgb)
    for index,loci in ch_pandas.iterrows():
        try:
            crd_y,crd_x=[i-half_crop for i in loci['crop_coordinates']]
            crd=[crd_x,crd_y]
            loci_rectangle=Rectangle(tuple(crd),pars['crop_size'],pars['crop_size'],
                                    linewidth=.4,edgecolor=loci["box_color"],facecolor='none')
            ax.add_patch(loci_rectangle)
            
            # loci["contour"]+=
            ax.plot(loci["contour"][:,1]+crd_x, loci["contour"][:,0]+crd_y, c="y",linewidth=.1)
            # print(loci['line'])
            # loci['line']=[i+crd for i in loci['line']]
            loci['line'][0]=[i+crd_x for i in loci['line'][0]]
            loci['line'][1]=[i+crd_y for i in loci['line'][1]]
            ax.plot(loci['line'][0],loci['line'][1],c="green",linewidth=.2)

            
            ax.annotate(str(index), c=loci["box_color"],fontsize=6, xy=(crd_x,crd_y),
                        xycoords='data', xytext=(half_crop,half_crop),textcoords='offset pixels')
        except:
            print('Something went wrong with crd plotting of image',str(loci['file_name']),str(loci['crop#']))
        
    legend_elements = [Patch(facecolor='g',edgecolor='g',label='OK'),
    Patch(facecolor='r',edgecolor='r',label='Noise'),
    Patch(facecolor='m',edgecolor='m',label='More than 1 object')]
    plt.legend(handles=legend_elements,bbox_to_anchor=(1,0), loc="lower right", 
                bbox_transform=fig.transFigure, ncol=4)
    title = "Channel:" + pars['ch_names'][ch]
    fig.suptitle(title, fontsize=10)
    return fig
                             
                             
    